## Method-based URL dispatcher for the Tornado web server  
Originally published: 2009-11-17 08:42:29  
Last updated: 2009-11-20 11:51:47  
Author: Dan McDougall  
  
The MethodDispatcher is a subclass of [tornado](http://www.tornadoweb.org/).web.RequestHandler that will use\nthe methods contained in subclasses of MethodDispatcher to handle requests.  In\nother words, instead of having to make a new RequestHandler class for every URL\nin your application you can subclass MethodDispatcher and use the methods\ncontained therein *as* your URLs.\n\nThe MethodDispatcher also adds the convenience of automatically passing\narguments to your class methods.  So there is no need to use Tornado's\nget_argument() method.\n\n**Example**\n-------\nTo demonstrate the advantages of using MethodDispatcher I'll present a standard\nTornado app with multiple URLs and re-write it using MethodDispatcher...\n\n**The standard Tornado way**\n------------------------\n    class Foo(tornado.web.RequestHandler):\n        def get(self):\n            self.write('foo')\n\n    class Bar(tornado.web.RequestHandler):\n        def get(self):\n            self.write('bar')\n\n    class SimonSays(tornado.web.RequestHandler):\n        def get(self):\n            say = self.get_argument("say")\n            self.write('Simon says, %s' % `say`)\n\n    application = tornado.web.Application([\n        (r"/foo", Foo),\n        (r"/bar", Bar),\n        (r"/simonsays", SimonSays),\n    ])\n\n**The MethodDispatcher way**\n------------------------\n    class FooBar(MethodDispatcher):\n        def foo(self):\n            self.write("foo")\n\n        def bar(self):\n            self.write("bar")\n\n        def simonsays(self, say):\n            self.write("Simon Says, %s" % `say`)\n\n    application = tornado.web.Application([\n        (r"/.*", FooBar)\n    ])\n\n**Notes**\n-----\nAs you can see from the above example, using the MethodDispatcher can\nsignificantly reduce the complexity of Tornado applications.  Here's some other\nthings to keep in mind when using the MethodDispatcher:\n\n * MethodDispatcher will ignore any methods that begin with an underscore (_).\n   This prevents builtins and private methods from being exposed to the web.\n * The '/' path is special: It always maps to self.index().\n * MethodDispatcher does not require that your methods distinquish between GET\n   and POST requests.  Whether a GET or POST is performed the matching method\n   will be called with any passed arguments or POSTed data.  Because of the way\n   this works you should not use get() and post() in your MethodDispatcher\n   subclasses unless you want to override this functionality.\n * When an argument is passed with a single value (/simonsays?say=hello) the\n   value passed to the argument will be de-listed.  In other words, it will be\n   passed to your method like so:  {'say': 'hello'}.  This overrides the\n   default Tornado behavior which would return the value as a list:\n   {'say': ['hello']}.  If more than one value is passed MethodDispatcher will\n   use the default behavior.